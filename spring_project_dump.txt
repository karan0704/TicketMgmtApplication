

--- File: .mvn\wrapper\maven-wrapper.properties ---
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip


--- File: src\main\java\ticketmgmt\TicketMgmtApplication.java ---
package ticketmgmt;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication(scanBasePackages = "ticketmgmt")
public class TicketMgmtApplication {

    public static void main(String[] args) {
        SpringApplication.run(TicketMgmtApplication.class, args);
    }

}


--- File: src\main\java\ticketmgmt\config\CorsConfig.java ---
package ticketmgmt.config;

import org.springframework.context.annotation.Configuration;

@Configuration
public class CorsConfig {
    // CORS configuration is handled in SecurityConfig
}

--- File: src\main\java\ticketmgmt\config\PasswordConfig.java ---
package ticketmgmt.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class PasswordConfig {
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}


--- File: src\main\java\ticketmgmt\config\PasswordEncoderConfig.java ---
package ticketmgmt.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class PasswordEncoderConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}


--- File: src\main\java\ticketmgmt\config\SecurityConfig.java ---
package ticketmgmt.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.http.HttpMethod;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers(HttpMethod.OPTIONS, "/**").permitAll() // Permit all OPTIONS requests for CORS preflight
                        .requestMatchers(
                                "/api/auth/**", // Allow authentication endpoints
                                "/error",
                                "/api/public/**"
                        ).permitAll() // Public access
                        .anyRequest().authenticated() // All other requests require authentication
                )
                .formLogin(form -> form
                        .loginPage("/api/auth/login")
                        .loginProcessingUrl("/api/auth/login")
                        .defaultSuccessUrl("/api/auth/login-success")
                        .failureUrl("/api/auth/login-failure")
                        .permitAll()
                )
                .logout(logout -> logout
                        .logoutUrl("/api/auth/logout")
                        .logoutSuccessUrl("/api/auth/logout-success")
                        .permitAll()
                )
                .sessionManagement(session -> session
                        .maximumSessions(1)
                        .maxSessionsPreventsLogin(false)
                );

        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList(
                "http://localhost:4200",
                "http://localhost:8000",
                "http://127.0.0.1:5500",
                "http://localhost:5500",
                "file://",
                "null"
        ));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

}

--- File: src\main\java\ticketmgmt\controller\AuthController.java ---
package ticketmgmt.controller;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.context.HttpSessionSecurityContextRepository;
import org.springframework.web.bind.annotation.*;
import ticketmgmt.dto.LoginRequest;
import ticketmgmt.dto.RegistrationRequest;
import ticketmgmt.model.User;
import ticketmgmt.service.UserService;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    private final AuthenticationManager authenticationManager;
    private final UserService userService;
    private final PasswordEncoder passwordEncoder;

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequest loginRequest, HttpServletRequest request) {
        try {
            // Authenticate user credentials
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            loginRequest.getUsername(), 
                            loginRequest.getPassword()
                    )
            );

            // Set authentication in security context
            SecurityContextHolder.getContext().setAuthentication(authentication);

            // Create session and store security context
            HttpSession session = request.getSession(true);
            session.setAttribute(HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY, 
                    SecurityContextHolder.getContext());

            // Create response with session information
            Map<String, Object> response = new HashMap<>();
            response.put("status", "success");
            response.put("message", "Login successful");
            response.put("username", loginRequest.getUsername());

            return ResponseEntity.ok(response);
        } catch (BadCredentialsException e) {
            Map<String, String> response = new HashMap<>();
            response.put("status", "error");
            response.put("message", "Invalid username or password");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
        }
    }

    @PostMapping("/register")
    public ResponseEntity<?> register(@RequestBody RegistrationRequest registrationRequest) {
        // Check if username already exists
        if (userService.existsByUsername(registrationRequest.getUsername())) {
            Map<String, String> response = new HashMap<>();
            response.put("status", "error");
            response.put("message", "Username already exists");
            return ResponseEntity.badRequest().body(response);
        }

        // Check if email already exists
        if (userService.existsByEmail(registrationRequest.getEmail())) {
            Map<String, String> response = new HashMap<>();
            response.put("status", "error");
            response.put("message", "Email already exists");
            return ResponseEntity.badRequest().body(response);
        }

        // Create new user
        User user = new User();
        user.setUsername(registrationRequest.getUsername());
        user.setEmail(registrationRequest.getEmail());
        user.setPassword(passwordEncoder.encode(registrationRequest.getPassword()));

        userService.saveUser(user);

        Map<String, String> response = new HashMap<>();
        response.put("status", "success");
        response.put("message", "User registered successfully");

        return ResponseEntity.ok(response);
    }

    @GetMapping("/login-success")
    public ResponseEntity<?> loginSuccess() {
        Map<String, String> response = new HashMap<>();
        response.put("status", "success");
        response.put("message", "You have been logged in successfully");
        return ResponseEntity.ok(response);
    }

    @GetMapping("/login-failure")
    public ResponseEntity<?> loginFailure() {
        Map<String, String> response = new HashMap<>();
        response.put("status", "error");
        response.put("message", "Login failed: Invalid credentials");
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
    }

    @PostMapping("/logout")
    public ResponseEntity<?> logout(HttpServletRequest request, HttpServletResponse response) {
        HttpSession session = request.getSession(false);
        if (session != null) {
            session.invalidate();
        }
        SecurityContextHolder.clearContext();

        Map<String, String> responseMap = new HashMap<>();
        responseMap.put("status", "success");
        responseMap.put("message", "Logged out successfully");

        return ResponseEntity.ok(responseMap);
    }

    @GetMapping("/logout-success")
    public ResponseEntity<?> logoutSuccess() {
        Map<String, String> response = new HashMap<>();
        response.put("status", "success");
        response.put("message", "You have been logged out successfully");
        return ResponseEntity.ok(response);
    }

    @GetMapping("/user-info")
    public ResponseEntity<?> getUserInfo() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !authentication.isAuthenticated() || 
                "anonymousUser".equals(authentication.getPrincipal())) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("User not authenticated");
        }

        UserDetails userDetails = (UserDetails) authentication.getPrincipal();
        Map<String, Object> response = new HashMap<>();
        response.put("username", userDetails.getUsername());
        response.put("authorities", userDetails.getAuthorities());

        return ResponseEntity.ok(response);
    }
}

--- File: src\main\java\ticketmgmt\controller\CustomerController.java ---
package ticketmgmt.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import ticketmgmt.model.Customer;
import ticketmgmt.repository.CustomerRepository;

import java.util.List;

@RestController
@RequestMapping("/api/customers")
@RequiredArgsConstructor
public class CustomerController {
    private final CustomerRepository customerRepository;

    @PostMapping
    public ResponseEntity<Customer> createCustomer(@RequestBody Customer customer) {
        return ResponseEntity.ok(customerRepository.save(customer));
    }

    @GetMapping
    public ResponseEntity<List<Customer>>
    getAllCustomers() {
        return ResponseEntity.ok(customerRepository.findAll());
    }

    @GetMapping("/{id}")
    ResponseEntity<Customer> getCustomer(@PathVariable Integer id) {
        return customerRepository.findById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());

    }
}


--- File: src\main\java\ticketmgmt\controller\EngineerController.java ---
package ticketmgmt.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import ticketmgmt.model.Engineer;
import ticketmgmt.repository.EngineerRepository;

import java.util.List;

@RestController
@RequestMapping("/api/engineers")
@RequiredArgsConstructor
public class EngineerController {

    private final EngineerRepository engineerRepository; // Inject EngineerRepository

    @GetMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    public ResponseEntity<List<Engineer>> getAllEngineers() {
        // This endpoint will return all engineers from the database
        return ResponseEntity.ok(engineerRepository.findAll());
    }

    // Optional: Add an endpoint to create engineers for testing
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Engineer> createEngineer(@RequestBody Engineer engineer) {
        return ResponseEntity.ok(engineerRepository.save(engineer));
    }
}
    

--- File: src\main\java\ticketmgmt\controller\FileUploadController.java ---
package ticketmgmt.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import ticketmgmt.service.FileStorageService;

@RestController
@RequestMapping("/api/files")
@RequiredArgsConstructor
public class FileUploadController {

    private final FileStorageService fileStorageService;

    @PostMapping("/upload/{ticketId}")
    public ResponseEntity<String> upload(@RequestParam MultipartFile file, @PathVariable Integer ticketId) {
        try {
            String path = fileStorageService.saveFile(file);
            fileStorageService.attachToTicket(ticketId, path); // ticket -> logFile
            return ResponseEntity.ok("File saved and attached to ticket ID: " + ticketId);
        } catch (Exception e) {
            return ResponseEntity.internalServerError().body("Failed to upload file");
        }
    }

    @GetMapping("/ticket/{ticketId}")
    public ResponseEntity<?> getFiles(@PathVariable Integer ticketId) {
        return ResponseEntity.ok(fileStorageService.getFilesByTicket(ticketId));
    }
}


--- File: src\main\java\ticketmgmt\controller\TicketController.java ---
package ticketmgmt.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import ticketmgmt.dto.TicketRequest;
import ticketmgmt.model.Ticket;
import ticketmgmt.model.TicketPriority;
import ticketmgmt.service.TicketService;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/tickets")
@RequiredArgsConstructor
public class TicketController {

    private final TicketService ticketService;

    @PostMapping("/create")
    public ResponseEntity<Ticket> createTicket(//@RequestParam String customerName, @RequestParam String issue,@RequestParam TicketPriority priority
                                               @RequestBody TicketRequest request) {
        Ticket created = ticketService.createTicket(request.getCustomerName(), request.getIssue(), request.getPriority());
        return ResponseEntity.ok(created);
    }

    @GetMapping("/{id}")
    public ResponseEntity<Ticket> getTicket(@PathVariable Integer id) {
        Optional<Ticket> ticket = ticketService.getTicketById(id);
        return ticket.map(ResponseEntity::ok).orElse(ResponseEntity.notFound().build());
    }

    @PostMapping("/{id}/assign/{engineerId}")
    public ResponseEntity<Ticket> assign(@PathVariable Integer id, @PathVariable Integer engineerId) {
        return ResponseEntity.ok(ticketService.assignTicketToEngineer(id, engineerId));
    }

    @PostMapping("/{id}/unassign")
    public ResponseEntity<Ticket> unassign(@PathVariable Integer id) {
        return ResponseEntity.ok(ticketService.unassignEngineer(id));
    }

    @GetMapping("/all")
    public ResponseEntity<List<Ticket>> getAllTickets() {
        return ResponseEntity.ok(ticketService.getAllTickets());
    }
}


--- File: src\main\java\ticketmgmt\dto\LoginRequest.java ---
package ticketmgmt.dto;

import lombok.Data;

@Data
public class LoginRequest {
    private String username;
    private String password;
}


--- File: src\main\java\ticketmgmt\dto\RegistrationRequest.java ---
package ticketmgmt.dto;

import lombok.Data;

@Data
public class RegistrationRequest {
    private String username;
    private String email;
    private String password;
}


--- File: src\main\java\ticketmgmt\dto\TicketRequest.java ---
package ticketmgmt.dto;

import lombok.Data;
import ticketmgmt.model.TicketPriority;

@Data

public class TicketRequest {
    private String customerName;
    private String issue;
    private TicketPriority priority;
}


--- File: src\main\java\ticketmgmt\filter\JwtRequestFilter.java ---
package ticketmgmt.filter;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import ticketmgmt.service.AppUserDetailsService;
import ticketmgmt.util.JwtUtil;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JwtRequestFilter extends OncePerRequestFilter {

    private final AppUserDetailsService userDetailsService;
    private final JwtUtil jwtUtil;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {

        final String authorizationHeader = request.getHeader("Authorization");

        String username = null;
        String jwt = null;

        // Check for Authorization header and Bearer token
        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            jwt = authorizationHeader.substring(7); // Extract JWT token
            username = jwtUtil.extractUsername(jwt); // Extract username from token
        }

        // If a username is found and no authentication is set in SecurityContext
        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);

            // Validate the token
            if (jwtUtil.validateToken(jwt, userDetails)) {
                // Create an authentication token and set it in SecurityContext
                UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                usernamePasswordAuthenticationToken
                        .setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);
            }
        }
        chain.doFilter(request, response); // Continue the filter chain
    }
}


--- File: src\main\java\ticketmgmt\model\AppUser.java ---
package ticketmgmt.model;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AppUser {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(unique = true)
    private String username;

    private String email;

    private String password;
    @Enumerated(EnumType.STRING)
    private Role role;
    @OneToMany(mappedBy = "user")
    @JsonIgnore
    private List<Ticket> tickets;

    public enum Role {
        ROLE_CUSTOMER, ROLE_ENGINEER
    }
}


--- File: src\main\java\ticketmgmt\model\AuditLog.java ---
package ticketmgmt.model;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AuditLog {

   @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    private String message;
    private LocalDateTime timestamp;

    @ManyToOne
    @JsonIgnore
    @JoinColumn(name = "ticket_id")
    private Ticket ticket;
}


--- File: src\main\java\ticketmgmt\model\Customer.java ---
package ticketmgmt.model;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    private String name;
    private String email;
    private String phoneNumber;
    private String companyName;

    @OneToMany(mappedBy = "customer", cascade = CascadeType.ALL)
    @JsonIgnore
    private List<Ticket> tickets;
}


--- File: src\main\java\ticketmgmt\model\Engineer.java ---
package ticketmgmt.model;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Engineer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    private String name;
    private String email;
    private String designation;

    @OneToMany(mappedBy = "assignedEngineer", cascade = CascadeType.ALL)
    @JsonIgnore
    private List<Ticket> assignedTickets;
}


--- File: src\main\java\ticketmgmt\model\IssueAttachment.java ---
package ticketmgmt.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class IssueAttachment {

   @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    private String fileName;
    private String filePath;

    @ManyToOne
    @JoinColumn(name = "ticket_id")
    private Ticket ticket;
}


--- File: src\main\java\ticketmgmt\model\LogFile.java ---
package ticketmgmt.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder

public class LogFile {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    private String filename;
    private String filePath;

    @ManyToOne
    @JoinColumn(name = "ticket_id")
    private Ticket ticket;
}


--- File: src\main\java\ticketmgmt\model\Ticket.java ---
package ticketmgmt.model;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder

public class Ticket {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    // private String customerName;
    private String issueDescription;

    @Enumerated(EnumType.STRING)
    private TicketStatus ticketStatus;

    @Enumerated(EnumType.STRING)
    private TicketPriority priority;

    private String ticketResponse;

    @OneToMany(mappedBy = "ticket", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<LogFile> logFiles;

    @OneToMany(mappedBy = "ticket", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<AuditLog> auditLogs;

    @ManyToOne
    @JoinColumn(name = "user_id")
    @JsonIgnore
    private AppUser user;

    @ManyToOne
    @JsonIgnore
    @JoinColumn(name = "customer_id")
    private Customer customer;

    @ManyToOne
    @JoinColumn(name = "engineer_id")
    @JsonIgnore
    private Engineer assignedEngineer;
}


--- File: src\main\java\ticketmgmt\model\TicketPriority.java ---
package ticketmgmt.model;

public enum TicketPriority {
        LOW, MEDIUM, HIGH, CRITICAL
}


--- File: src\main\java\ticketmgmt\model\TicketStatus.java ---
package ticketmgmt.model;

public enum TicketStatus {
    OPEN, ACKNOWLEDGED, CLOSED
}


--- File: src\main\java\ticketmgmt\model\User.java ---
package ticketmgmt.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Collections;

@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
public class User implements UserDetails {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String username;

    @Column(nullable = false)
    private String password;

    @Column(unique = true, nullable = false)
    private String email;

    private boolean accountNonExpired = true;
    private boolean accountNonLocked = true;
    private boolean credentialsNonExpired = true;
    private boolean enabled = true;

    private String role = "ROLE_USER"; // Default role

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singletonList(new SimpleGrantedAuthority(role));
    }

    @Override
    public boolean isAccountNonExpired() {
        return accountNonExpired;
    }

    @Override
    public boolean isAccountNonLocked() {
        return accountNonLocked;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return credentialsNonExpired;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }
}


--- File: src\main\java\ticketmgmt\repository\AppUserRepository.java ---
package ticketmgmt.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import ticketmgmt.model.AppUser;

import java.util.Optional;

@Repository
public interface AppUserRepository extends JpaRepository<AppUser, Integer> {
    Optional<AppUser> findByUsername(String username);
}


--- File: src\main\java\ticketmgmt\repository\AuditLogRepository.java ---
package ticketmgmt.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import ticketmgmt.model.AuditLog;

public interface AuditLogRepository extends JpaRepository<AuditLog, Integer> {
}


--- File: src\main\java\ticketmgmt\repository\CustomerRepository.java ---
package ticketmgmt.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import ticketmgmt.model.Customer;

import java.util.Optional;

public interface CustomerRepository extends JpaRepository<Customer, Integer> {
    Optional<Customer> findByName(String name);
}


--- File: src\main\java\ticketmgmt\repository\EngineerRepository.java ---
package ticketmgmt.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import ticketmgmt.model.Engineer;

public interface EngineerRepository extends JpaRepository<Engineer, Integer> {
}


--- File: src\main\java\ticketmgmt\repository\IssueAttachmentRepository.java ---
package ticketmgmt.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import ticketmgmt.model.IssueAttachment;

public interface IssueAttachmentRepository extends JpaRepository<IssueAttachment,Integer> {
}


--- File: src\main\java\ticketmgmt\repository\LogFileRepository.java ---
package ticketmgmt.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import ticketmgmt.model.LogFile;

import java.util.List;

public interface LogFileRepository extends JpaRepository<LogFile, Integer> {
    List<LogFile> findByTicketId(Integer ticketId);
}


--- File: src\main\java\ticketmgmt\repository\TicketRepository.java ---
package ticketmgmt.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import ticketmgmt.model.Ticket;

public interface TicketRepository extends JpaRepository<Ticket, Integer> {
}


--- File: src\main\java\ticketmgmt\repository\UserRepository.java ---
package ticketmgmt.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import ticketmgmt.model.User;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    Optional<User> findByEmail(String email);
    boolean existsByUsername(String username);
    boolean existsByEmail(String email);
}


--- File: src\main\java\ticketmgmt\service\AppUserDetailsService.java ---
package ticketmgmt.service;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import ticketmgmt.model.AppUser;
import ticketmgmt.repository.AppUserRepository;

@Service
@RequiredArgsConstructor
@ComponentScan("ticketmgmt.repository")
public class AppUserDetailsService implements UserDetailsService {

    private final AppUserRepository repository;


    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        AppUser user = repository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("Username not found"));
        System.out.println("User loaded: " + user.getUsername() + ", Role: " + user.getRole());

        String role = user.getRole().name();
        if (role.startsWith("ROLE_")) {
            role = role.substring(5);
        }

        return org.springframework.security.core.userdetails.User
                .withUsername(user.getUsername())
                .password(user.getPassword())
                .roles(role)
                //.roles(user.getRole().name())
                .build();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }

}



--- File: src\main\java\ticketmgmt\service\AuditLogService.java ---
package ticketmgmt.service;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import ticketmgmt.model.AuditLog;
import ticketmgmt.model.Ticket;
import ticketmgmt.repository.AuditLogRepository;

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
public class AuditLogService {

    private final AuditLogRepository auditLogRepository;

    public void log(Ticket ticket, String message) {
        AuditLog log = AuditLog.builder()
                .ticket(ticket)
                .message(message)
                .timestamp(LocalDateTime.now())
                .build();
        auditLogRepository.save(log);
    }
}


--- File: src\main\java\ticketmgmt\service\FileStorageService.java ---
package ticketmgmt.service;

import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import ticketmgmt.model.LogFile;
import ticketmgmt.model.Ticket;
import ticketmgmt.repository.LogFileRepository;
import ticketmgmt.repository.TicketRepository;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class FileStorageService {

    private static final String UPLOAD_DIR = "uploads";

    private final TicketRepository ticketRepository;
    private final LogFileRepository logFileRepository;

    /**
     * Save a file to the local file system.
     *
     * @param file MultipartFile uploaded from frontend/Postman
     * @return the stored file's full path as String
     * @throws IOException if file can't be saved
     */
    public String saveFile(MultipartFile file) throws IOException {
        Path uploadPath = Paths.get(UPLOAD_DIR);

        if (!Files.exists(uploadPath)) {
            Files.createDirectories(uploadPath);
        }

        String filename = System.currentTimeMillis() + "_" + file.getOriginalFilename();
        Path filePath = uploadPath.resolve(filename);
        file.transferTo(filePath.toFile());

        return filePath.toString();
    }

    /**
     * Save a file and associate it with a specific ticket.
     *
     * @param ticketId The ID of the ticket to attach the file to
     * @param filePath Full path of the uploaded file
     */
    @Transactional
    public void attachToTicket(Integer ticketId, String filePath) {
        Ticket ticket = ticketRepository.findById(ticketId)
                .orElseThrow(() -> new RuntimeException("Ticket not found"));

        LogFile logFile = LogFile.builder()
                .filePath(filePath)
                .ticket(ticket)
                .build();

        logFileRepository.save(logFile);
    }

    /**
     * Get all file paths attached to a ticket.
     *
     * @param ticketId The ticket ID
     * @return List of file paths as Strings
     */
    public List<String> getFilesByTicket(Integer ticketId) {
        return logFileRepository.findByTicketId(ticketId)
                .stream()
                .map(LogFile::getFilePath)
                .collect(Collectors.toList());
    }
}


--- File: src\main\java\ticketmgmt\service\TicketService.java ---
package ticketmgmt.service;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import ticketmgmt.model.*;
import ticketmgmt.repository.CustomerRepository;
import ticketmgmt.repository.EngineerRepository;
import ticketmgmt.repository.TicketRepository;

import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class TicketService {

    private final TicketRepository ticketRepository;
    private final CustomerRepository customerRepository;
    private final EngineerRepository engineerRepository;
    private final AuditLogService auditLogService;

    // Create new ticket and associate with a customer
    public Ticket createTicket(String customerName, String issue, TicketPriority priority) {
        Customer customer = customerRepository.findByName(customerName)
                .orElseThrow(() -> new RuntimeException("Customer not found"));

        Ticket ticket = Ticket.builder()
                //.customerName(customerName)
                .issueDescription(issue)
                .ticketStatus(TicketStatus.OPEN)
                .priority(priority)
                .ticketResponse("Ticket created")
                .customer(customer)
                .build();

        Ticket savedTicket = ticketRepository.save(ticket);
        auditLogService.log(savedTicket, "Ticket created");
        return savedTicket;
    }

    // Get a ticket by ID
    public Optional<Ticket> getTicketById(Integer ticketId) {
        return ticketRepository.findById(ticketId);
    }

    // Engineer chooses (claims) a ticket
    public Ticket assignTicketToEngineer(Integer ticketId, Integer engineerId) {
        Ticket ticket = ticketRepository.findById(ticketId)
                .orElseThrow(() -> new RuntimeException("Ticket not found"));
        Engineer engineer = engineerRepository.findById(engineerId)
                .orElseThrow(() -> new RuntimeException("Engineer not found"));

        ticket.setAssignedEngineer(engineer);
        auditLogService.log(ticket, "Assigned to engineer: " + engineer.getName());
        return ticketRepository.save(ticket);
    }

    // Engineer removes themselves from ticket
    public Ticket unassignEngineer(Integer ticketId) {
        Ticket ticket = ticketRepository.findById(ticketId)
                .orElseThrow(() -> new RuntimeException("Ticket not found"));

        ticket.setAssignedEngineer(null);
        auditLogService.log(ticket, "Unassigned engineer");
        return ticketRepository.save(ticket);
    }

    // Get all tickets
    public List<Ticket> getAllTickets() {
        return ticketRepository.findAll();
    }
}


--- File: src\main\java\ticketmgmt\service\UserService.java ---
package ticketmgmt.service;

import ticketmgmt.model.User;

public interface UserService {
    User saveUser(User user);
    User findByUsername(String username);
    User findByEmail(String email);
    boolean existsByUsername(String username);
    boolean existsByEmail(String email);
}


--- File: src\main\java\ticketmgmt\service\impl\UserServiceImpl.java ---
package ticketmgmt.service.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import ticketmgmt.model.User;
import ticketmgmt.repository.UserRepository;
import ticketmgmt.service.UserService;

@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService, UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public User saveUser(User user) {
        return userRepository.save(user);
    }

    @Override
    public User findByUsername(String username) {
        return userRepository.findByUsername(username)
                .orElse(null);
    }

    @Override
    public User findByEmail(String email) {
        return userRepository.findByEmail(email)
                .orElse(null);
    }

    @Override
    public boolean existsByUsername(String username) {
        return userRepository.existsByUsername(username);
    }

    @Override
    public boolean existsByEmail(String email) {
        return userRepository.existsByEmail(email);
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        return userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));
    }
}


--- File: src\main\java\ticketmgmt\util\JwtUtil.java ---
package ticketmgmt.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Component
public class JwtUtil {

    // Secret key for JWT signing. This should be a strong, randomly generated key.
    // In a production environment, store this securely (e.g., environment variable).
    @Value("${jwt.secret}")
    private String SECRET_KEY;

    // Expiration time for the token (e.g., 10 hours)
    @Value("${jwt.expiration}")
    private long JWT_TOKEN_VALIDITY; // in milliseconds

    // Retrieve username from JWT token
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    // Retrieve expiration date from a JWT token
    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    // Generic method to extract a specific claim from the token
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    // Retrieve all claims from the token
    private Claims extractAllClaims(String token) {
        return Jwts.parserBuilder().setSigningKey(getSigningKey()).build().parseClaimsJws(token).getBody();
    }

    // Check if the token has expired
    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    // Generate token for user
    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        // Add roles to claims
        claims.put("roles", userDetails.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(java.util.stream.Collectors.toList()));
        return createToken(claims, userDetails.getUsername());
    }

    // Create the token
    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(subject)
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + JWT_TOKEN_VALIDITY))
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    // Validate token
    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }

    // Get the signing key from the secret
    private Key getSigningKey() {
        // Use recommended method to create a secure key for HS256
        if (SECRET_KEY == null || SECRET_KEY.trim().isEmpty()) {
            // If no secret key is provided, generate a secure key
            return Keys.secretKeyFor(SignatureAlgorithm.HS256);
        }

        try {
            byte[] keyBytes = Decoders.BASE64.decode(SECRET_KEY);
            // Verify key length meets requirements (≥ 256 bits for HS256)
            if (keyBytes.length * 8 < 256) {
                throw new IllegalArgumentException("The JWT secret key is too short");
            }
            return Keys.hmacShaKeyFor(keyBytes);
        } catch (Exception e) {
            // Fallback to a secure generated key if there's any issue with the provided key
            return Keys.secretKeyFor(SignatureAlgorithm.HS256);
        }
    }
}


--- File: src\main\resources\application.properties ---
# Database Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/ticketmgmt
spring.datasource.username=root
spring.datasource.password=root@1234
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA Config
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.format_sql=true

# Server
server.port=8080

# File Upload (optional)
file.upload-dir=uploads

# Logging
debug=true
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.springframework.security=DEBUG
logging.level.org.springframework.context=DEBUG

spring.main.allow-bean-definition-overriding=true

spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

# JWT Configuration
# Using a more secure key that meets the 256-bit minimum requirement for HS256
jwt.secret=c9DSPZcbBFVmH9vj7Y5AWYHQSNc4XzqJrzMdMPe2XUkH2w2mXPkxwMrVvnvhsyRg
# 10 hours in milliseconds (10 * 60 * 60 * 1000)
jwt.expiration=36000000


--- File: src\test\java\ticketmgmt\TicketMgmtApplicationTests.java ---
package ticketmgmt;


import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class TicketMgmtApplicationTests {

    @Test
    void contextLoads() {
    }

}

--- File: target\classes\application.properties ---
# Database Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/ticketmgmt
spring.datasource.username=root
spring.datasource.password=root@1234
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA Config
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.format_sql=true

# Server
server.port=8080

# File Upload (optional)
file.upload-dir=uploads

# Logging
debug=true
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.springframework.security=DEBUG
logging.level.org.springframework.context=DEBUG

spring.main.allow-bean-definition-overriding=true

spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

# JWT Configuration
# Using a more secure key that meets the 256-bit minimum requirement for HS256
jwt.secret=c9DSPZcbBFVmH9vj7Y5AWYHQSNc4XzqJrzMdMPe2XUkH2w2mXPkxwMrVvnvhsyRg
# 10 hours in milliseconds (10 * 60 * 60 * 1000)
jwt.expiration=36000000
